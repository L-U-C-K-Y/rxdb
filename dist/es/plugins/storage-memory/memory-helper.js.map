{"version":3,"file":"memory-helper.js","names":["pushAtSortPosition","newRxError","boundEQ","getMemoryCollectionKey","databaseName","collectionName","ensureNotRemoved","instance","internals","removed","Error","attachmentMapKey","documentId","attachmentId","SORT_BY_INDEX_STRING","a","b","indexString","putWriteRowToState","docId","state","stateByIndex","row","docInState","documents","set","document","forEach","byIndex","docsWithIndex","newIndexString","getIndexableString","insertPosition","id","doc","previousIndexString","prev","splice","next","args","indexBefore","compareDocsWithIndex","removeDocFromState","primaryPath","schema","delete","Object","values","positionInIndex"],"sources":["../../../../src/plugins/storage-memory/memory-helper.ts"],"sourcesContent":["import type {\n    BulkWriteRow,\n    RxDocumentData,\n    RxJsonSchema\n} from '../../types';\nimport type {\n    DocWithIndexString,\n    MemoryStorageInternals,\n    MemoryStorageInternalsByIndex\n} from './memory-types';\nimport type { RxStorageInstanceMemory } from './rx-storage-instance-memory';\nimport {\n    pushAtSortPosition\n} from 'array-push-at-sort-position';\nimport { newRxError } from '../../rx-error';\nimport { boundEQ } from './binary-search-bounds';\n\n\nexport function getMemoryCollectionKey(\n    databaseName: string,\n    collectionName: string\n): string {\n    return databaseName + '--memory--' + collectionName;\n}\n\n\nexport function ensureNotRemoved(\n    instance: RxStorageInstanceMemory<any>\n) {\n    if (instance.internals.removed) {\n        throw new Error('removed');\n    }\n}\n\nexport function attachmentMapKey(documentId: string, attachmentId: string): string {\n    return documentId + '||' + attachmentId;\n}\n\nconst SORT_BY_INDEX_STRING = (a: DocWithIndexString<any>, b: DocWithIndexString<any>) => {\n    if (a.indexString < b.indexString) {\n        return -1;\n    } else {\n        return 1;\n    }\n};\n\n\n\nexport function putWriteRowToState<RxDocType>(\n    docId: string,\n    state: MemoryStorageInternals<RxDocType>,\n    stateByIndex: MemoryStorageInternalsByIndex<RxDocType>[],\n    row: BulkWriteRow<RxDocType>,\n    docInState?: RxDocumentData<RxDocType>\n) {\n    state.documents.set(docId, row.document as any);\n    stateByIndex.forEach(byIndex => {\n        const docsWithIndex = byIndex.docsWithIndex;\n        const newIndexString = byIndex.getIndexableString(row.document as any);\n        const [, insertPosition] = pushAtSortPosition(\n            docsWithIndex,\n            {\n                id: docId,\n                doc: row.document,\n                indexString: newIndexString\n            },\n            SORT_BY_INDEX_STRING,\n            true\n        );\n\n        /**\n         * Remove previous if it was in the state\n         */\n        if (docInState) {\n            const previousIndexString = byIndex.getIndexableString(docInState);\n            if (previousIndexString === newIndexString) {\n                /**\n                 * Index not changed -> The old doc must be before or after the new one.\n                 */\n                const prev = docsWithIndex[insertPosition - 1];\n                if (prev && prev.id === docId) {\n                    docsWithIndex.splice(insertPosition - 1, 1);\n                } else {\n                    const next = docsWithIndex[insertPosition + 1];\n                    if (next.id === docId) {\n                        docsWithIndex.splice(insertPosition + 1, 1);\n                    } else {\n                        throw newRxError('SNH', {\n                            args: {\n                                row,\n                                byIndex\n                            }\n                        });\n                    }\n                }\n            } else {\n                /**\n                 * Index changed, we must search for the old one and remove it.\n                 */\n                const indexBefore = boundEQ(\n                    docsWithIndex,\n                    {\n                        indexString: previousIndexString\n                    } as any,\n                    compareDocsWithIndex\n                );\n                docsWithIndex.splice(indexBefore, 1);\n            }\n        }\n    });\n}\n\n\nexport function removeDocFromState<RxDocType>(\n    primaryPath: string,\n    schema: RxJsonSchema<RxDocumentData<RxDocType>>,\n    state: MemoryStorageInternals<RxDocType>,\n    doc: RxDocumentData<RxDocType>\n) {\n    const docId: string = (doc as any)[primaryPath];\n    state.documents.delete(docId);\n\n    Object.values(state.byIndex).forEach(byIndex => {\n        const docsWithIndex = byIndex.docsWithIndex;\n        const indexString = byIndex.getIndexableString(doc);\n\n        const positionInIndex = boundEQ(\n            docsWithIndex,\n            {\n                indexString\n            } as any,\n            compareDocsWithIndex\n        );\n        docsWithIndex.splice(positionInIndex, 1);\n    });\n}\n\n\nexport function compareDocsWithIndex<RxDocType>(\n    a: DocWithIndexString<RxDocType>,\n    b: DocWithIndexString<RxDocType>\n): 1 | 0 | -1 {\n    if (a.indexString < b.indexString) {\n        return -1;\n    } else if (a.indexString === b.indexString) {\n        return 0;\n    } else {\n        return 1;\n    }\n}\n"],"mappings":"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"}